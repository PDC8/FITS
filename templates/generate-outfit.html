<!-- generate-outfit.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Random Outfit - Digital Closet</title>
  <link rel="stylesheet" href="/static/base.css" />
  <link rel="stylesheet" href="/static/generate-outfit.css" />
  <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
</head>
<body>
  <header>
    <nav class="main-nav">
      <div class="nav-section left-links">
        <a href="/upload">Upload</a>
        <a href="/random-outfit">Generate</a>
      </div>
      <div class="logo">
        <img src="logo.png" alt="Logo">
      </div>
      <div class="nav-section right-links">
        <a href="/search">Search</a>
        <a href="/logout">Profile</a>
      </div>
    </nav>
  </header>

  <main class="outfit-generator">
    <div class="scroll-bar">
      <div class="clothing-list"></div>
    </div>
    <div class="generate">
      <button class="generate-btn" type="button">
        Generate Outfit
      </button>
      <div class="outfit-canvas">
      </div>
    </div>

  </main>
  <script>
    document.querySelector('.generate-btn').addEventListener('click', async () => {
      try {
        const response = await fetch('/api/outfit/random');
        const outfit = await response.json();
        const resultsDiv = document.querySelector('.outfit-result');
        resultsDiv.innerHTML = ''; // Clear previous results
        
        // Create a container to display the outfit
        const outfitContainer = document.createElement('div');
        outfitContainer.className = 'outfit-container';
        
        // Define the display order
        const order = ['tops', 'bottoms', 'shoes'];
        
        // Loop through in fixed order
        order.forEach(category => {
          const item = outfit[category];
          const itemDiv = document.createElement('div');
          itemDiv.className = 'outfit-item';
          if (item) {
            let html = `<h3>${category.toUpperCase()}</h3>`;
            html += `<p><strong>Name:</strong> ${item.item_name}</p>`;
            if (item.type_name) {
              html += `<p><strong>Type:</strong> ${item.type_name}</p>`;
            }
            if (item.brand_name) {
              html += `<p><strong>Brand:</strong> ${item.brand_name}</p>`;
            }
            if (item.size_name) {
              html += `<p><strong>Size:</strong> ${item.size_name}</p>`;
            }
            if (item.color_names && item.color_names.length > 0) {
              html += `<p><strong>Color(s):</strong> ${item.color_names.join(', ')}</p>`;
            }
            if (item.fabric_names && item.fabric_names.length > 0) {
              html += `<p><strong>Fabric(s):</strong> ${item.fabric_names.join(', ')}</p>`;
            }
            if (item.item_image) {
              html += `<img src="data:image/png;base64,${item.item_image}" alt="${item.item_name}" width="150">`;
            }
            itemDiv.innerHTML = html;
          } else {
            itemDiv.innerHTML = `<h3>${category.toUpperCase()}</h3><p>No item available</p>`;
          }
          outfitContainer.appendChild(itemDiv);
        });
        resultsDiv.appendChild(outfitContainer);
      } catch (error) {
        console.error('Error generating outfit:', error);
      }
    });

    let dragPreview = null;
    let currentTarget = null;
    document.addEventListener('DOMContentLoaded', async () => {
      try {
        const response = await fetch('/api/clothing');
        const items = await response.json();
        const clothingList = document.querySelector('.clothing-list');
        items.forEach(item => {
          const itemDiv = document.createElement('div');
          itemDiv.className = 'draggable-item';
          itemDiv.dataset.itemId = item.item_id;
          let html = '';
          if (item.item_image) {
            html += `<img src="data:image/png;base64,${item.item_image}" alt="${item.item_name}" width="100">`;
          }
          html += `<p>${item.item_name}</p>`;
          itemDiv.innerHTML = html;
          clothingList.appendChild(itemDiv);
        });
        initDraggables();
      } catch (error) {
        console.error('Error loading items:', error);
      }
    });

  let originalParent = null;
  let originalPosition = null;

  function initDraggables() {
    interact('.draggable-item').draggable({
      modifiers: [
        interact.modifiers.restrictRect({
          restriction: 'body',
          endOnly: true
        })
      ],
      listeners: {
        start(event) {
          const target = event.target;
          // Store original position
          originalParent = target.parentNode;
          originalPosition = {
            x: target.offsetLeft,
            y: target.offsetTop
          };
          
          // Make item position fixed during drag
          target.style.position = 'fixed';
          target.style.zIndex = '10000';
          target.style.width = `${target.offsetWidth}px`;

          // Get current dimensions after setting fixed width
          const width = target.offsetWidth;
          const height = target.offsetHeight;
          
          // Calculate centered position based on mouse coordinates
          const startX = event.clientX - width / 2;
          const startY = event.clientY - height / 2;
          
          // Set initial position and update data attributes
          target.style.left = `${startX}px`;
          target.style.top = `${startY}px`;
          target.dataset.x = startX;
          target.dataset.y = startY;
        },
        move(event) {
          const target = event.target;
          // Update position during drag
          const x = (parseFloat(target.dataset.x) || 0) + event.dx;
          const y = (parseFloat(target.dataset.y) || 0) + event.dy;
          
          target.style.left = `${x}px`;
          target.style.top = `${y}px`;
          target.dataset.x = x;
          target.dataset.y = y;
        },
        end(event) {
          const target = event.target;
          // Reset if not dropped in canvas
          if (!target.classList.contains('in-canvas')) {
            resetPosition(target);
          }
        }
      }
    });

    interact('.outfit-canvas').dropzone({
      accept: '.draggable-item',
      ondrop: (event) => {
        const canvas = event.target;
        const target = event.relatedTarget;
        const canvasRect = canvas.getBoundingClientRect();
        
        // Convert fixed position to canvas-relative
        const x = parseFloat(target.style.left) - canvasRect.left;
        const y = parseFloat(target.style.top) - canvasRect.top;
        
        // Position in canvas
        target.style.position = 'absolute';
        target.style.left = `${x}px`;
        target.style.top = `${y}px`;
        target.style.zIndex = 'auto';
        target.classList.add('in-canvas');
        
        // Append to canvas
        canvas.appendChild(target);
      }
    });
  }

  function resetPosition(target) {
    // Return item to original position
    target.style.position = 'static';
    target.style.width = 'auto';
    target.style.zIndex = 'auto';
    originalParent.appendChild(target);
    target.style.transform = `translate(${originalPosition.x}px, ${originalPosition.y}px)`;
  }
  </script>  
  
</body>
</html>
